// Generated by CoffeeScript 2.3.2
var cleanup, fs, handle_error, k, kdestroy, kinit, krb5, spnego;

k = require('../build/Release/krb5');

fs = require('fs');

cleanup = function(ctx, princ, ccache) {
  if (princ) {
    k.krb5_free_principal_sync(ctx, princ);
  }
  if (ccache) {
    return k.krb5_cc_close(ctx, ccache, function(err) {
      if (ctx) {
        return k.krb5_free_context_sync(ctx);
      }
    });
  } else {
    if (ctx) {
      return k.krb5_free_context_sync(ctx);
    }
  }
};

handle_error = function(callback, err, ctx, princ, ccache) {
  if (!err) {
    return err;
  }
  err = k.krb5_get_error_message_sync(ctx, err);
  cleanup(ctx, princ, ccache);
  return callback(Error(err));
};

kinit = function(options, callback) {
  var do_ccache, do_creds, do_init, do_principal, do_realm, split;
  if (!options.principal) {
    return callback(Error('Please specify principal for kinit'));
  }
  if (!(options.password || options.keytab)) {
    return callback(Error('Please specify password or keytab for kinit'));
  }
  if (options.principal.indexOf('@') !== -1) {
    split = options.principal.split('@');
    options.principal = split[0];
    options.realm = split[1];
  }
  do_init = function() {
    return k.krb5_init_context(function(err, ctx) {
      if (err) {
        return handle_error(callback, err);
      }
      return do_realm(ctx);
    });
  };
  do_realm = function(ctx) {
    if (!options.realm) {
      return k.krb5_get_default_realm(ctx, function(err, realm) {
        if (err) {
          return handle_error(callback, err, ctx);
        }
        options.realm = realm;
        return do_principal(ctx);
      });
    } else {
      return do_principal(ctx);
    }
  };
  do_principal = function(ctx) {
    return k.krb5_build_principal(ctx, options.realm.length, options.realm, options.principal, function(err, princ) {
      if (err) {
        return handle_error(callback, err, ctx);
      }
      return do_ccache(ctx, princ);
    });
  };
  do_ccache = function(ctx, princ) {
    if (options.ccname) {
      if (options.ccname.indexOf(':KEYRING') !== -1) {
        cleanup(ctx, princ);
        return callback(Error('KEYRING method not supported.'));
      }
      return k.krb5_cc_resolve(ctx, options.ccname, function(err, ccache) {
        if (err) {
          return handle_error(callback, err, ctx, princ);
        }
        return do_creds(ctx, princ, ccache);
      });
    } else {
      return k.krb5_cc_default(ctx, function(err, ccache) {
        if (err) {
          return handle_error(callback, err, ctx, princ);
        }
        return do_creds(ctx, princ, ccache);
      });
    }
  };
  do_creds = function(ctx, princ, ccache) {
    var ccname, get_creds_keytab, get_creds_password, store_creds;
    ccname = k.krb5_cc_get_name_sync(ctx, ccache);
    fs.exists(ccname, function(exists) {
      if (!exists) {
        return k.krb5_cc_initialize(ctx, ccache, princ, function(err) {
          if (err) {
            return handle_error(callback, err, ctx, princ);
          }
          if (options.password) {
            return get_creds_password();
          } else {
            return get_creds_keytab();
          }
        });
      } else {
        if (options.password) {
          return get_creds_password();
        } else {
          return get_creds_keytab();
        }
      }
    });
    get_creds_password = function() {
      return k.krb5_get_init_creds_password(ctx, princ, options.password, function(err, creds) {
        if (err) {
          return handle_error(callback, err, ctx, princ, ccache);
        }
        return store_creds(creds);
      });
    };
    get_creds_keytab = function() {
      return k.krb5_kt_resolve(ctx, options.keytab, function(err, kt) {
        if (err) {
          return handle_error(callback, err, ctx, princ, ccache);
        }
        return k.krb5_get_init_creds_keytab(ctx, princ, kt, 0, function(err, creds) {
          if (err) {
            return handle_error(callback, err, ctx, princ, ccache);
          }
          return store_creds(creds);
        });
      });
    };
    return store_creds = function(creds) {
      return k.krb5_cc_store_cred(ctx, ccache, creds, function(err) {
        if (err) {
          return handle_error(callback, err, ctx, princ, ccache);
        }
        cleanup(ctx, princ, ccache);
        return callback(void 0, ccname);
      });
    };
  };
  return do_init();
};

kdestroy = function(options, callback) {
  var do_ccache, do_destroy;
  k.krb5_init_context(function(err, ctx) {
    if (err) {
      return handle_error(callback, err, ctx);
    }
    return do_ccache(ctx);
  });
  do_ccache = function(ctx) {
    if (options.ccname) {
      return k.krb5_cc_resolve(ctx, options.ccname, function(err, ccache) {
        if (err) {
          return handle_error(callback, err, ctx, null, ccache);
        }
        return do_destroy(ctx, ccache);
      });
    } else {
      return k.krb5_cc_default(ctx, function(err, ccache) {
        if (err) {
          return handle_error(callback, err, ctx, null, ccache);
        }
        return do_destroy(ctx, ccache);
      });
    }
  };
  return do_destroy = function(ctx, ccache) {
    return k.krb5_cc_destroy(ctx, ccache, function(err) {
      if (err) {
        return handle_error(callback, err, ctx);
      }
      return callback(void 0);
    });
  };
};

spnego = function(options, callback) {
  var service_principal_or_fqdn;
  service_principal_or_fqdn = null;
  if (service_principal_or_fqdn == null) {
    service_principal_or_fqdn = options.service_principal;
  }
  if (service_principal_or_fqdn == null) {
    service_principal_or_fqdn = options.service_fqdn;
  }
  if (!service_principal_or_fqdn) {
    return callback(Error('Missing property "service_principal" or "service_fqdn"'));
  }
  if (!/HTTP[@\/]/.test(service_principal_or_fqdn)) {
    service_principal_or_fqdn = `HTTP@${service_principal_or_fqdn}`;
  }
  if (options.ccname == null) {
    options.ccname = "";
  }
  return k.generate_spnego_token(service_principal_or_fqdn, options.ccname, function(gss_err, gss_minor, token) {
    return callback((gss_err === 0 ? void 0 : gss_minor), token);
  });
};

krb5 = function() {
  var err, options, queue, work;
  options = arguments[0];
  queue = [];
  err = null;
  work = function() {
    var args, name;
    if (!queue.length) {
      return;
    }
    [name, args] = queue.shift();
    switch (name) {
      case 'kinit':
        return kinit(options, function(err, ccname) {
          if (typeof args[0] === 'function') {
            args[0](err, ccname);
          }
          if (!err) {
            return work();
          }
        });
      case 'kdestroy':
        return kdestroy(options, function(err) {
          if (typeof args[0] === 'function') {
            args[0](err);
          }
          return work();
        });
      case 'spnego':
        return spnego(options, function(err, token) {
          if (typeof args[0] === 'function') {
            args[0](err, token);
          }
          return work();
        });
    }
  };
  process.nextTick(work);
  return {
    kinit: function() {
      queue.push(['kinit', arguments]);
      return this;
    },
    kdestroy: function() {
      queue.push(['kdestroy', arguments]);
      return this;
    },
    spnego: function() {
      queue.push(['spnego', arguments]);
      return this;
    }
  };
};

krb5.spnego = spnego;

krb5.kinit = kinit;

krb5.kdestroy = function(options, callback) {
  if (typeof options === 'function') {
    return kdestroy({}, options);
  } else {
    return kdestroy(options, callback);
  }
};

module.exports = krb5;
