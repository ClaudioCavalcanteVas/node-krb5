// Generated by CoffeeScript 2.2.4
var cleanup, fs, handle_error, k, kinit, krb5, spnego;

k = require('../build/Release/krb5');

fs = require('fs');

cleanup = function(ctx, princ, ccache) {
  if (princ) {
    k.krb5_free_principal_sync(ctx, princ);
  }
  if (ccache) {
    return k.krb5_cc_close(ctx, ccache, function(err) {
      if (ctx) {
        return k.krb5_free_context_sync(ctx);
      }
    });
  } else if (ctx) {
    return k.krb5_free_context_sync(ctx);
  }
};

handle_error = function(callback, err, ctx, princ, ccache) {
  if (!err) {
    return err;
  }
  err = k.krb5_get_error_message_sync(ctx, err);
  cleanup(ctx, princ, ccache);
  return callback(Error(err));
};

kinit = function(options, callback) {
  if (!options.username || !options.realm) {
    return callback(Error('Please specify user and realm for kinit'));
  }
  if (!options.password && !options.keytab) {
    return callback(Error('Please specify password or keytab for kinit'));
  }
  return k.krb5_init_context(function(err, ctx) {
    if (err) {
      return handle_error(callback, err, ctx);
    }
    return k.krb5_build_principal(ctx, options.realm.length, options.realm, options.username, function(err, princ) {
      var creds;
      if (err) {
        return handle_error(callback, err, ctx, princ);
      }
      if (options.ccname) {
        if (options.ccname.indexOf(':KEYRING') !== -1) {
          cleanup(ctx, princ);
          return callback(Error('KEYRING method not supported.'));
        }
        process.env.KRB5CCNAME = options.ccname;
        k.krb5_cc_resolve(ctx, options.ccname, function(err, ccache) {
          if (err) {
            return handle_error(callback, err, ctx, princ, ccache);
          }
          return creds(ccache);
        });
      } else {
        k.krb5_cc_default(ctx, function(err, ccache) {
          if (err) {
            return handle_error(callback, err, ctx, princ, ccache);
          }
          return creds(ccache);
        });
      }
      return creds = function(ccache) {
        var ccname;
        ccname = k.krb5_cc_get_name_sync(ctx, ccache);
        return fs.exists(ccname, function(exists) {
          var create_cc, get_creds_keytab, get_creds_password, store_creds;
          create_cc = function(create_cc_callback) {
            if (!exists) {
              return k.krb5_cc_initialize(ctx, ccache, princ, function(err) {
                if (err) {
                  return handle_error(callback, err, ctx, princ, ccache);
                }
                return create_cc_callback();
              });
            } else {
              return create_cc_callback();
            }
          };
          get_creds_password = function() {
            return k.krb5_get_init_creds_password(ctx, princ, options.password, function(err, creds) {
              if (err) {
                return handle_error(callback, err, ctx, princ, ccache);
              }
              return store_creds(creds);
            });
          };
          get_creds_keytab = function() {
            return k.krb5_kt_resolve(ctx, options.keytab, function(err, kt) {
              if (err) {
                return handle_error(callback, err, ctx, princ, ccache);
              }
              return k.krb5_get_init_creds_keytab(ctx, princ, kt, 0, function(err, creds) {
                if (err) {
                  return handle_error(callback, err, ctx, princ, ccache);
                }
                return store_creds(creds);
              });
            });
          };
          store_creds = function(creds) {
            return k.krb5_cc_store_cred(ctx, ccache, creds, function(err) {
              if (err) {
                return handle_error(callback, err, ctx, princ, ccache);
              }
              ccname = k.krb5_cc_get_name_sync(ctx, ccache);
              return callback(void 0, ccname);
            });
          };
          create_cc(options.password ? get_creds_password : get_creds_keytab);
        });
      };
    });
  });
};

spnego = function(options, callback) {
  var service_principal_or_fqdn;
  if (options.ccname) {
    process.env.KRB5CCNAME = options.ccname;
  }
  service_principal_or_fqdn = null;
  if (service_principal_or_fqdn == null) {
    service_principal_or_fqdn = options.service_principal;
  }
  if (service_principal_or_fqdn == null) {
    service_principal_or_fqdn = options.service_fqdn;
  }
  if (!service_principal_or_fqdn) {
    return callback(Error('Missing property "service_principal" or "service_fqdn"'));
  }
  if (!/HTTP[@\/]/.test(service_principal_or_fqdn)) {
    service_principal_or_fqdn = `HTTP@${service_principal_or_fqdn}`;
  }
  return k.generate_spnego_token(service_principal_or_fqdn, function(gss_err, gss_minor, token) {
    return callback((gss_err === 0 ? void 0 : gss_err), token);
  });
};

krb5 = function() {
  var err, options, queue, work;
  options = arguments[0];
  queue = [];
  err = null;
  work = function() {
    var args, name;
    if (!queue.length) {
      return;
    }
    [name, args] = queue.shift();
    switch (name) {
      case 'kinit':
        return kinit(options, function(err, ccname) {
          if (typeof args[0] === 'function') {
            args[0](err, ccname);
          }
          if (!err) {
            return work();
          }
        });
      case 'spnego':
        spnego(options, function(err, token) {
          if (typeof args[0] === 'function') {
            return args[0](err, token);
          }
        });
        return work();
    }
  };
  process.nextTick(work);
  return {
    kinit: function() {
      queue.push(['kinit', arguments]);
      return this;
    },
    spnego: function() {
      queue.push(['spnego', arguments]);
      return this;
    }
  };
};

krb5.kinit = kinit;

krb5.spnego = spnego;

module.exports = krb5;

// TODO

// err undefined et non 0
